import re
import json
import os

INPUT_FILE = '/Users/eddybouchenak/Documents/GEMINI_APP/MOTSHASARD/SCRIPT_PYTHON/mots_tries.txt'
OUTPUT_FILE = '/Users/eddybouchenak/Documents/GEMINI_APP/MOTSHASARD/js/data.js'

def parse_and_process_words(file_path):
    # Structure: WORDS_BY_RANK[rank][letter] -> list of words
    # rank is 1-based (1 to 6)
    words_by_rank = {i: {} for i in range(1, 7)}
    all_words = set() # Use set to avoid duplicates

    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()

        for line in lines:
            line = line.strip()
            # Extract word from line like: "ABRICOT", or "ABRICOT"
            match = re.search(r'"([A-Z]+)"', line)
            if match:
                word = match.group(1)
                
                # Filter out markers if any remain
                if word in ['DEBUT', 'FIN', 'LISTE', 'VIDE']:
                    continue

                # valid length check (at least 6 chars as requested)
                length = len(word)
                if length < 6:
                    continue

                all_words.add(word)

                # Index by rank
                # For each position 1..6
                for rank in range(1, 7):
                    # verify word has enough letters for this rank
                    # rank 1 = index 0
                    index = rank - 1
                    if index < length:
                        letter = word[index]
                        if letter not in words_by_rank[rank]:
                            words_by_rank[rank][letter] = []
                        words_by_rank[rank][letter].append(word)

        return words_by_rank, list(all_words)

    except Exception as e:
        print(f"Error processing file: {e}")
        return None, None

def generate_js_file(words_by_rank, all_words, output_path):
    if not words_by_rank:
        print("No data to write.")
        return

    # Sort all lists for consistency
    all_words.sort()
    for rank in words_by_rank:
        for letter in words_by_rank[rank]:
            words_by_rank[rank][letter].sort()

    # Manual construction for better readability with comments
    js_content = "// Generated by transform_data.py\n"
    js_content += "// WORDS_BY_RANK[rank][letter] = array of words\n\n"
    
    js_content += "const WORDS_BY_RANK = {\n"
    
    for rank in range(1, 7):
        js_content += f"    // --- POSITION {rank} ---\n"
        js_content += f'    "{rank}": '
        # Dump the dict for this rank specifically
        rank_json = json.dumps(words_by_rank[rank], indent=4, ensure_ascii=False)
        # Indent it properly to fit nested structure
        rank_json_indented = rank_json.replace('\n', '\n    ')
        js_content += rank_json_indented + ",\n\n"

    js_content += "};\n\n"
    
    js_content += f"const WORDS = {json.dumps(all_words, indent=4, ensure_ascii=False)};\n\n"
    js_content += "// Expose to global scope\n"
    js_content += "window.WORDS_BY_RANK = WORDS_BY_RANK;\n"
    js_content += "window.WORDS = WORDS;\n"

    try:
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(js_content)
        print(f"Successfully generated {output_path}")
        print(f"Total unique words: {len(all_words)}")
    except Exception as e:
        print(f"Error writing JS file: {e}")

if __name__ == "__main__":
    print(f"Processing {INPUT_FILE}...")
    ranked_data, flat_data = parse_and_process_words(INPUT_FILE)
    if ranked_data:
        generate_js_file(ranked_data, flat_data, OUTPUT_FILE)
